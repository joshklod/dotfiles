" Backend
if has("multi_byte")
	set encoding =utf-8
endif

" Recognize custom xterm-style terminals - Vim internally sets extra termcap
" settings for terminals containing 'xterm'
if &term =~ 'mintty\|hterm'
	set term =xterm-truecolor
endif

" Source default vimrc
if filereadable($VIMRUNTIME . "/defaults.vim")
	unlet! skip_defaults_vim
	silent! source $VIMRUNTIME/defaults.vim
endif

if has("eval")
	" Check whether file exists in 'runtimepath'
	function! s:ExistsRTP(path)
		return !empty(globpath(&rtp, a:path))
	endfunction

	" Handy shortcut for name of runtimepath directory in $HOME on current
	" system (because Windows just has to be different...)
	let s:homertp = $HOME . (has("win32") ? "/vimfiles" : "/.vim")

	" Compatible with termguicolors
	" Termguicolors requires that both the terminal and Vim are truecolor
	" capable.  The environment variable $COLORTERM is usually not set
	" automatically - this must be done manually (typically in .bashrc) when
	" using a truecolor-capable terminal.
	let s:has_tgc = has("termguicolors") && $COLORTERM == "truecolor"

	" Some features only look good with at least 256 colors
	let s:fancy_colors = &t_Co >= 256 || s:has_tgc || has("gui_running")
endif

" Plugins
if s:ExistsRTP("autoload/pathogen.vim")
	" Start plugin manager
	execute pathogen#infect()
endif
if has("autocmd")
	filetype plugin indent on
endif

" Syntax highlighting
set background =dark
if has("syntax")
	if s:has_tgc
		set termguicolors
	endif
	syntax enable
	if s:ExistsRTP("colors/solarized.vim") && s:fancy_colors
		if &t_Co >= 256
			let g:solarized_termcolors =256
		endif
		let g:solarized_menu       =0
		colorscheme solarized
	else
		colorscheme industry
	endif
	if s:ExistsRTP("autoload/togglebg.vim")
		call togglebg#map("")
	endif

	" Color Overrides
	if has("terminal")
		highlight Terminal ctermbg=0 ctermfg=7 guibg=black guifg=lightgray
	endif
endif

" Movement
set scrolloff     =8
set nostartofline

" Visual indicators
set list
" Set this first, then reset it in case we don't have +eval
set listchars =tab:>\ ,trail:~,extends:>,precedes:<,nbsp:\ "
if has("multi_byte")
	" Use let instead of set so we don't have to include unicode chars
	" literally
	let &listchars = "tab:\u203a ,trail:\u00b7,extends:\u00bb,"
	             \ . "precedes:\u00ab,nbsp:\u00b7"
endif
if has("syntax")
	if s:fancy_colors
		set cursorline
	endif
	set colorcolumn =+2 " Always 2 columns right of textwidth
endif
set number norelativenumber
if has("linebreak")
	set numberwidth =3
endif
if has("cmdline_info")
	set ruler " Show file position info on statusline
	if has("statusline")
		set rulerformat=%5l,%v%=\ %P " Hide byte column number
	endif
endif
if has("cursorshape") && &term =~ 'xterm'
	" Cursor Shape Reference:
	"                Blinking Solid
	"          Block     1      2
	"     Underscore     3      4
	"            Bar     5      6
	"          Reset     0      0
	let &t_EI .= "\<Esc>[2 q" " Normal Mode
	let &t_SI .= "\<Esc>[5 q" " Insert Mode
	let &t_SR .= "\<Esc>[3 q" " Replace Mode

	let &t_ti .= "\<Esc>[2 q" " Vim Start
	let &t_te .= "\<Esc>[0 q" " Vim Exit
endif

" Spell checking
if has("syntax")
	set spelllang =en_us
	let &spellfile = s:homertp . "/spell/local.utf-8.add,"
	             \ . s:homertp . "/spell/personal.utf-8.add"
endif

" Tab behavior
set tabstop     =4
set shiftwidth  =0 " Use value of tabstop
set softtabstop =0 " Disabled
set smarttab       " Use shiftwidth at beginning of line, and tabstop (or
                   "   softtabstop) elsewhere
set noexpandtab
set autoindent     " Keep indent of previous line

" Line wrapping
set nowrap
set formatoptions =croqlj " Hard wrapping behavior
if has("linebreak")
	set linebreak
	if exists("&breakindent")
		set breakindent
		set breakindentopt =min:20,shift:8
	endif
	if has("multi_byte")
		let &showbreak = "\u00bb "
	else
		set showbreak =>\ "
	endif
endif

" Window behavior
if has("windows")
	set splitbelow
	set laststatus =2 " Always show status line
	if has("vertsplit")
		set splitright
		" Leave extra space for line numbers
		if has("linebreak")
			let &winwidth = 80 + &numberwidth
		else
			set winwidth =83
		endif
		set winminwidth =20
	endif
endif

" Editing behavior
if has("virtualedit")
	set virtualedit =block
endif
set textwidth     =78
if has("mouse")
	set mouse =a " Enable mouse
	if has("mouse_sgr")
		set ttymouse =sgr " Enable advanced mouse behavior
	endif
endif

" Tags
set tags +=./.tags,.tags,/usr/local/lib/**/tags,/usr/local/lib/**/.tags

" Navigation
nmap <X1Mouse> <C-O>
nmap <X2Mouse> <C-I>

" Searching
set ignorecase
set smartcase  " Ignore case only when all lowercase
if has("extra_search")
	set hlsearch
endif

" Folding
set foldminlines =4

" Macros
" Change word
nmap <silent> cc lbce
" Search in all files
nnoremap <Leader>* :let @/='\<'.expand("<cword>").'\>'<CR>
                 \ :vimgrep /<C-R>// %:p:h/*<CR>

" Delete trailing whitespace
nmap <Leader>d <Plug>DelWhite
vmap <Leader>d <Plug>DelWhite

if has("eval")
	" Using a function preserves search history and hlsearch
	function! s:DelWhite()
		let line = getline(".")
		let repl = substitute(line, '\s\+$', "", "")
		call setline(".", repl)
	endfunction
	noremap <silent> <SID>DelWhite :call <SID>DelWhite()<CR>
endif
sil! while 0 " No eval
	" Fall back to basic search command
	noremap <silent> <SID>DelWhite :s/\s\+$//e <Bar> nohlsearch<CR>
sil! endwhile
nnoremap <script> <Plug>DelWhite <SID>DelWhite
vnoremap <script> <Plug>DelWhite <SID>DelWhite

" Toggle 'spell' option
nmap <F8> <Plug>ToggleSpell
vmap <F8> <Plug>ToggleSpell
imap <F8> <Plug>ToggleSpell

nnoremap <silent>  <SID>ToggleSpell :set spell! <Bar> set spell?<CR>
nnoremap <script> <Plug>ToggleSpell      <SID>ToggleSpell
vnoremap <script> <Plug>ToggleSpell <Esc><SID>ToggleSpell<Esc>gv
inoremap <script> <Plug>ToggleSpell <C-O><SID>ToggleSpell

" Custom commands
if has("user_commands")
	" Show all tabstop-related options
	command! -bar Taboptions set ts? sw? sts? et? sta?
	command! -bar Topt       Taboptions

	" Open scratchpad in new buffer
	command! -bar Scratch  new  | setl bt=nofile bh=hide noswf
	command! -bar Vscratch vnew | setl bt=nofile bh=hide noswf

	" Open giti terminal in new window
	command! -bar Giti  term giti
	command! -bar Vgiti vert term giti

	" Replace smart quotes with ASCII quotes
	command! -bar -range QuoteFix
				\ silent! <line1>,<line2>s/\%u2018\|\%u2019/'/g |
				\ silent! <line1>,<line2>s/\%u201c\|\%u201d/"/g
endif

" Source local vimrc
if filereadable(s:homertp."/local.vimrc")
	execute 'source '.s:homertp."/local.vimrc"
endif
